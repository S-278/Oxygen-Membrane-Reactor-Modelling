# -*- coding: utf-8 -*-
"""
Created on Mon Feb  5 18:25:17 2024

@author: elijah.bakaleynik
"""
from Experiment import Experiment
from Optimization import symmetric_inner_filter, step_filter
from abc import ABC, abstractmethod
import copy
from enum import Enum; from enum import auto as e_auto
import pint; u=pint.UnitRegistry()

# ~~~~~~~~~~ PHYSICAL CONSTANTS ~~~~~~~~~~
GAS_CONST = 8.314 * u.J/(u.mol * u.degK)
GRAV_ACCEL = 9.81 * u.m/(u.s**2)
CH4_M_Molar = 16.04 * u.g/u.mol
H2O_M_Molar =  18.015 * u.g/u.mol
CH4_HHV = 55384 * u.kJ/u.kg * CH4_M_Molar
CO_HHV = 10160 * u.kJ/u.kg * 28.01 * u.g/u.mol
H2_HHV = 142081 * u.kJ/u.kg * 2.016 * u.g/u.mol
H2Og_Cp_SLOPE = (0.000665666 * u.kJ/(u.kg*u.degK**2) * H2O_M_Molar)\
                .to(u.J/(u.mol*u.degK**2))
H2Og_Cp_INT = (1.62065 * u.kJ/(u.kg*u.degK) * H2O_M_Molar)\
              .to(u.J/(u.mol*u.degK))
CH4_Cp_SLOPE = (0.00333164 * u.kJ/(u.kg*u.degK**2) * CH4_M_Molar)\
               .to(u.J/(u.mol*u.degK**2))
CH4_Cp_INT = (1.2229 * u.kJ/(u.kg*u.degK) * CH4_M_Molar)\
             .to(u.J/(u.mol*u.degK))
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     
class Metrics(dict):
    """Dictionary which records process model metrics
    
    This class is simply a dict with its __str__ method overriden
    to print some of the metrics generated by a Process Model.
    """
    
    def __str__(self):
        col_template = '{: <20}{: >20}\n'
        endl_template = '{: <5}{: >35}\n'
        ret = ''
        ret += f'{"External heat consumption":~^50}\n'
        ret += col_template.format('Reactor:', f'{self["reactor_heat_supply"].to_compact():.2f}')
        ret += col_template.format('H2O boiling:', f'{self["H2O_boil_cons"].to_compact():.2f}')
        ret += col_template.format('Preheating:', f'{self["H2O_preheat_cons"].to_compact()+self["CH4_preheat_cons"].to_compact():.2f}')
        ret += '{: >40}\n'.format(f'(F:{self["H2O_preheat_cons"].to_compact():.2f}/S:{self["CH4_preheat_cons"].to_compact():.2f})')
        ret += col_template.format('CO2 sep:', f'{self["CO2_sep_heat_cons"].to_compact():.2f}')
        ret += endl_template.format('TOTAL', f'{self["ext_heat_cons"].to_compact():.2f}')
        ret += f'{"Electricity consumption":~^50}\n'
        ret += col_template.format('H2O purification:', f'{self["H2O_pur_cons"].to_compact():.2f}')
        ret += col_template.format('F pumping:', f'{self["H2Ol_pump_cons"].to_compact()+self["H2Og_pump_cons"].to_compact():.2f}')
        ret += col_template.format('S pumping:', f'{self["CH4_pump_cons"].to_compact():.2f}')
        ret += col_template.format('Condensers:', f'{self["H2_condenser_cons"].to_compact()+self["CH4_condenser_cons"].to_compact():.2f}')
        ret += col_template.format('CO2 sep:', f'{self["CO2_sep_elec_cons"].to_compact():.2f}')
        ret += endl_template.format('TOTAL', f'{self["elec_consumed"].to_compact():.2f}')
        ret += endl_template.format('BAL', f'{self["elec_balance"].to_compact():.2f}')
        return ret
    
    def remove_builtins(d : dict):
        """Remove all dunder members of d"""
        for var_name in list(d):
            if (var_name.startswith('__') and var_name.endswith('__')): 
                del d[var_name]

            
class ProcessModel(ABC):
    """Process Model for evaluating an Experiment
    
    This is an abstract base class for an object that evaluates an Experiment. 
    A subclass of ProcessModel must implement the eval_experiment method,
    which provides a scalar evaluation score for a given Experiment.
    
    Public methods and attributes:
        eval_experiment() -- evaluate an Experiment
    """
    
    @abstractmethod
    def eval_experiment(self, exp: Experiment) -> float:
        """Evaluate an Experiment and produce a score
        
        Parameters
        ----------
        exp : Experiment
            Experiment to be evaluated.

        Returns
        -------
        float
            Evaluation score. Higher is better.

        """
        ...
            
def syngas_ratio_filter(ratio: float) -> float:
    """Enforces a 2:1 syngas H2:CO ratio"""
    return symmetric_inner_filter(ratio,
                                  2/1, 0.5, 5)
    
class Eff_PM(ProcessModel):
    """Evaluates Experiments based on the process energy efficiency
    
    Public methods and attributes:
        get_energy_eff() -- calculate the process energy efficiency of an Experiment
    """
    
    # ~~~~~~~~~~ PROCESS MODEL PARAMETERS ~~~~~~~~~~
    H2O_CYCLE_LOSS = 0.10
    H2O_PURIF_CONS = 4.52e-5 * u.kWh/u.mol
    H2O_BOILING_CONS = 76.6 * u.kJ/u.mol
    AMBIENT_T = u.Quantity(25, u.degC)
    AMBIENT_P = 101325 * u.Pa
    HX_EFF = 0.9
    REACTOR_HEAT_LOSS = 0.10
    CONDENSER_CW_FLOW_RATIO = 2/1
    CONDENSER_CW_PUMPING_CONS = 0.7e-6 * u.kWh/u.mol
    CO2_SEP_E_CONS = 9 * u.kJ/u.mol
    CO2_SEP_H_CONS = 132 * u.kJ/u.mol
    RANKINE_EFF = 0.4
    PUMPING_HEIGHT = 100 * u.m
    PUMPING_EFF = 0.7
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    ambient_RT = GAS_CONST * AMBIENT_T.to("degK")
    boil_RT = GAS_CONST * u.Quantity(100, u.degC).to("degK")
    CH4_spec_grav_energy = CH4_M_Molar * GRAV_ACCEL * PUMPING_HEIGHT
    H2Ol_spec_grav_energy = H2O_M_Molar * GRAV_ACCEL * PUMPING_HEIGHT
    
    def get_energy_eff(self, exp: Experiment, metrics : Metrics = None) -> float:  
        """Calculate the process energy efficiency of an Experiment
        
        Uses the operating point and membrane parameters recorded in the 
        given Experiment as inputs into a process model to calculate 
        a process energy efficiency.

        Parameters
        ----------
        exp : Experiment
            Experiment recording the membrane and operating point parameters.
        metrics : Metrics, optional
            If a Metrics object is provided, it will be populated with 
            various intermediate results from the energy efficiency calculation.

        Returns
        -------
        float
            Process energy efficiency, [0,1).

        """
        
        # This method populates Metrics by saving all local variables
        # that survive until the method end into the passed Metrics object.
        # At the start, the dict of function parameters is saved so that 
        # the function parameters can be subtracted from the locals at the end.
        funct_params = copy.deepcopy(locals()); Metrics.remove_builtins(funct_params)

        # External heat input:
        # Reactor heat supply (reaction heat + heat loss)
        reactor_heat_supply =                                                \
            exp.dH * u.W *                                                   \
            (1 + self.REACTOR_HEAT_LOSS/(1-self.REACTOR_HEAT_LOSS))
        # Input water boiling
        H2O_boil_cons = exp.N_f0 * u.mol/u.min * self.H2O_BOILING_CONS
        # Preheating:
        exp_T = u.Quantity(exp.T, u.degC).to(u.degK)
        # Input water preheating
        boil_T = u.Quantity(100,u.degC).to(u.degK)
        H2O_preheat_cons =                                      \
            exp.N_f0 * u.mol/u.min * (                          \
                  H2Og_Cp_SLOPE/2 * (exp_T**2 - boil_T**2)      \
                  + H2Og_Cp_INT * (exp_T - boil_T)              \
            ) * (1-self.HX_EFF)
        del boil_T
        # Input methane preheating
        amb_T = self.AMBIENT_T.to(u.degK)
        CH4_preheat_cons =                                \
            exp.N_s0 * u.mol/u.min * (                    \
                  CH4_Cp_SLOPE/2 * (exp_T**2 - amb_T**2)  \
                  + CH4_Cp_INT * (exp_T - amb_T)          \
            ) * (1-self.HX_EFF)
        del amb_T
        del exp_T
        # CO2 separation
        CO2_sep_heat_cons = exp.s_CO2_prod * u.mol/u.min * self.CO2_SEP_H_CONS
        
        ext_heat_cons = reactor_heat_supply                       \
                            + H2O_boil_cons + H2O_preheat_cons    \
                            + CH4_preheat_cons                    \
                            + CO2_sep_heat_cons
        
        # External electricity input:
        # Calculate how much electricity 
        # can be recovered from waste heat.
        waste_heat_recovered = exp.dH * u.W / ( (1-self.REACTOR_HEAT_LOSS)/self.REACTOR_HEAT_LOSS )
        elec_produced = waste_heat_recovered * self.RANKINE_EFF
        # Calculate total electricity consumption:
        # Input water purification
        H2O_pur_cons = exp.N_f0 * u.mol/u.min * self.H2O_CYCLE_LOSS * self.H2O_PURIF_CONS 
        # Input pumping
        H2Ol_pump_cons = exp.N_f0 * u.mol/u.min * self.H2Ol_spec_grav_energy / self.PUMPING_EFF
        
        H2Og_pump_cons = 0 * u.W
        if exp.P_f * u.Pa > self.AMBIENT_P:
            H2Og_pump_cons = exp.N_f0 * u.mol/u.min                             \
                             * (exp.P_f*u.Pa - self.AMBIENT_P)/self.AMBIENT_P   \
                             * self.boil_RT / self.PUMPING_EFF
                             
        CH4_pump_cons = exp.N_s0 * u.mol/u.min * (                                                  \
                              self.CH4_spec_grav_energy                                             \
                              + (exp.P_s * u.Pa - self.AMBIENT_P)/self.AMBIENT_P * self.ambient_RT  \
                        ) / self.PUMPING_EFF
        if CH4_pump_cons < 0: CH4_pump_cons = 0 * u.W
            
        # Condenser operation
        H2_condenser_cons =                             \
            exp.N_f * u.mol/u.min                       \
            * self.CONDENSER_CW_FLOW_RATIO              \
            * self.CONDENSER_CW_PUMPING_CONS            \
            / self.PUMPING_EFF
        CH4_condenser_cons=                                                         \
            exp.N_s * u.mol/u.min                                                   \
            * (exp.x_s[exp.x_comp.index("CH4")] + exp.x_s[exp.x_comp.index("CO")])  \
            * self.CONDENSER_CW_FLOW_RATIO                                          \
            * self.CONDENSER_CW_PUMPING_CONS                                        \
            / self.PUMPING_EFF
        # CO2 separation
        CO2_sep_elec_cons = exp.s_CO2_prod * u.mol/u.min * self.CO2_SEP_E_CONS

        elec_consumed = H2O_pur_cons                                        \
                        + H2Ol_pump_cons + CH4_pump_cons + H2Og_pump_cons   \
                        + H2_condenser_cons + CH4_condenser_cons            \
                        + CO2_sep_elec_cons

        # Subtract recovered electricity:
        elec_balance = elec_produced - elec_consumed
        # Discard electricity surplus but track electricity deficit:
        ext_elec_cons = -1*elec_balance if elec_balance < 0 else 0*u.W
        
        # Inflowing HHV
        HHV_in_CH4 = exp.N_s0 * u.mol/u.min * exp.CH4_conv * CH4_HHV
        HHV_in_tot = HHV_in_CH4
        
        # Outflowing HHV
        HHV_out_H2_f = exp.f_H2_prod * u.mol/u.min * H2_HHV
        HHV_out_H2_s = exp.s_H2_prod * u.mol/u.min * H2_HHV
        HHV_out_CO = exp.s_CO_prod * u.mol/u.min * CO_HHV
        HHV_out_tot = HHV_out_H2_f + HHV_out_H2_s + HHV_out_CO
        
        P_in = ext_heat_cons + ext_elec_cons + HHV_in_tot; P_in.ito("W")
        P_out = HHV_out_tot; P_out.ito("W")
        efficiency_tot = P_out/P_in
        
        if (metrics != None):
            metrics_to_add = copy.deepcopy(locals()); Metrics.remove_builtins(metrics_to_add)
            for param_name in funct_params:
                del metrics_to_add[param_name]
            del metrics_to_add["funct_params"]
            for quantity in metrics_to_add.values():
                try: quantity.ito("W")
                except pint.DimensionalityError: pass
            metrics.update(metrics_to_add)
            
        return efficiency_tot.magnitude
    
    def eval_experiment(self, exp: Experiment) -> float:
        # Evaluate by stacking a "bandpass" filter to enforce a 2:1 syngas ratio
        # with the process efficiency
        return self.get_energy_eff(exp) * \
               syngas_ratio_filter(exp.s_H2_prod/exp.s_CO_prod)
    
class Spec_N_o2_PM(Eff_PM):
    """Evaluates Experiments based on the process efficiency and an oxygen flux target
    
    This ProcessModel works like the Eff_PM,
    except it also demands that an Experiment achieves a minimum 
    membrane oxygen flux per unit membrane area.
    """
    
    def eval_experiment(self, exp: Experiment) -> float:
        return self.get_energy_eff(exp)                              \
               * syngas_ratio_filter(exp.s_H2_prod/exp.s_CO_prod)    \
               * step_filter(exp.N_o2 / exp.A_mem, 4.4e-5, 0.9e-5)

class Scenarios(Enum):
    """Enumerates Process Model scenarios"""
    PESSIMISTIC = e_auto()
    CENTRAL = e_auto()
    OPTIMISTIC = e_auto()

class ModelParameter(dict):
    """For now, just an alias for dict"""
    pass

class Scenario_PM(Spec_N_o2_PM):
    """Calculates the process energy efficiency based on model scenarios
    
    This ProcessModel defines multiple model scenarios, 
    where each scenario has its own set of process model parameters.
    The experiment evaluation then uses the selected scenario
    along with the syngas ratio and target oxygen flux requirements.
    
    Public methods and attributes:
        MODEL_PARAMETERS -- dictionary mapping the parameter name to the 
            parameter values stored as a ModelParameter. A ModelParameter is 
            indexed using the Scenarios enum.
        scenario_def -- dict defining which scenario is in use for each 
            model parameter. Entries in this dict should map a model parameter 
            name (according to MODEL_PARAMETERS) to a value of the Scenarios enum.
    """
    
    def __get_param(self, param_name):
        scenario = None
        try:
            scenario = self.scenario_def[param_name]
        except KeyError:
            scenario = Scenarios.CENTRAL
        return self.MODEL_PARAMETERS[param_name][scenario]
        
    def __add_param_property(param_name):
        return property(fget=lambda self: self.__get_param(param_name))

    MODEL_PARAMETERS = {
        'H2O_CYCLE_LOSS' : ModelParameter({
            Scenarios.PESSIMISTIC : 0.4,
            Scenarios.CENTRAL : 0.1,
            Scenarios.OPTIMISTIC : 0.05}),
        'H2O_PURIF_CONS' : ModelParameter({
            Scenarios.PESSIMISTIC : 7.23e-5 * u.kWh/u.mol,
            Scenarios.CENTRAL : 4.52e-5 * u.kWh/u.mol,
            Scenarios.OPTIMISTIC : 3.61e-5 * u.kWh/u.mol}),
        'H2O_BOILING_CONS' : ModelParameter({
            Scenarios.PESSIMISTIC : 66.9 * u.kJ/u.mol,
            Scenarios.CENTRAL : 52.6 * u.kJ/u.mol,
            Scenarios.OPTIMISTIC : 49.3 * u.kJ/u.mol}),
        'HX_EFF' : ModelParameter({
            Scenarios.PESSIMISTIC : 0.64,
            Scenarios.CENTRAL : 0.8,
            Scenarios.OPTIMISTIC : 0.9}),
        'REACTOR_HEAT_LOSS' : ModelParameter({
            Scenarios.PESSIMISTIC : 0.3,
            Scenarios.CENTRAL : 0.10,
            Scenarios.OPTIMISTIC : 0.08}),
        'CONDENSER_CW_FLOW_RATIO' : ModelParameter({
            Scenarios.PESSIMISTIC : 4/1,
            Scenarios.CENTRAL : 2/1,
            Scenarios.OPTIMISTIC : 1.5/1}),
        'RANKINE_EFF' : ModelParameter({
            Scenarios.PESSIMISTIC : 0.32,
            Scenarios.CENTRAL : 0.4,
            Scenarios.OPTIMISTIC : 0.48}),
        'PUMPING_EFF' : ModelParameter({
            Scenarios.PESSIMISTIC : 0.56,
            Scenarios.CENTRAL : 0.7,
            Scenarios.OPTIMISTIC : 0.84})
    }
    
    H2O_CYCLE_LOSS = __add_param_property('H2O_CYCLE_LOSS')
    H2O_PURIF_CONS = __add_param_property('H2O_PURIF_CONS')
    H2O_BOILING_CONS = __add_param_property('H2O_BOILING_CONS')
    HX_EFF = __add_param_property('HX_EFF')
    REACTOR_HEAT_LOSS = __add_param_property('REACTOR_HEAT_LOSS')
    CONDENSER_CW_FLOW_RATIO = __add_param_property('CONDENSER_CW_FLOW_RATIO')
    RANKINE_EFF = __add_param_property('RANKINE_EFF')
    PUMPING_EFF = __add_param_property('PUMPING_EFF')
    
    def __init__(self, scenario_def: dict = dict()):
        self.scenario_def = scenario_def     
        
    


        
    